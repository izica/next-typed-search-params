{"version":3,"file":"index.umd.min.js","sources":["../src/configure/settings.ts","../src/helpers/stringifySearchParams.ts","../src/helpers/setSearchParams.ts","../src/helpers/parseValue.ts","../src/helpers/parseSearchParams.ts","../src/configure/index.ts","../src/hooks/useSearchParams.ts"],"sourcesContent":["import type { ArrayFormatType } from \"../types/ArrayFormatType\";\n\nclass Settings {\n    arrayFormat: ArrayFormatType = \"bracket\";\n    arrayFormatSeparator: string = \",\";\n}\n\nconst settings = new Settings();\n\nexport { settings as Settings }\n","import queryString from \"query-string\";\n\nimport { Settings } from \"../configure/settings\";\n\nexport const stringifySearchParams = (searchParams: Record<string, any>): string => {\n    return queryString.stringify(searchParams, {\n        arrayFormat: Settings.arrayFormat,\n        arrayFormatSeparator: ',',\n        encode: false,\n        skipNull: true,\n        skipEmptyString: true,\n    });\n}\n","import { stringifySearchParams } from \"./stringifySearchParams\";\n\nexport const setSearchParams = (entry: Record<string, any>) => {\n    const href = `${window.location.pathname}?` + stringifySearchParams(entry);\n    history.replaceState({\n        ...history.state,\n        as: href,\n        new: href\n    }, \"\", href);\n\n    window.dispatchEvent(new Event('setSearchParams'));\n}\n","import { z } from \"zod\";\n\nexport const parseValue = (value: any, schema: z.ZodType | undefined) => {\n    if (schema === undefined) {\n        return undefined;\n    }\n    const { success, data } = schema.safeParse(value);\n    if (success) {\n        return data\n    }\n\n    return undefined;\n}\n","import { z } from \"zod\";\nimport queryString from \"query-string\";\n\nimport { parseValue } from \"./parseValue\";\nimport { Settings } from \"../configure/settings\";\n\nexport const parseSearchParams = <T, >(schema: Record<string, z.ZodType>, searchParamsString: string): T => {\n    const parsedSearchParams = queryString.parse(decodeURIComponent(searchParamsString), {\n        arrayFormat: Settings.arrayFormat,\n    });\n    const result: Record<string, any> = {};\n\n    for (let key in schema) {\n        result[key] = parseValue(parsedSearchParams[key], schema[key] || undefined);\n    }\n\n    return result as T;\n}\n","import type { ArrayFormatType } from \"../types/ArrayFormatType\";\nimport { Settings } from \"./settings\";\n\nexport function configure(options: {\n    arrayFormat?: ArrayFormatType,\n    arrayFormatSeparator?: string\n}) {\n    if (options[\"arrayFormat\"]) {\n        Settings.arrayFormat = options[\"arrayFormat\"];\n    }\n\n    if (options[\"arrayFormatSeparator\"]) {\n        Settings.arrayFormatSeparator = options[\"arrayFormatSeparator\"];\n    }\n}\n","import { useSearchParams as useSearchParamsNext } from \"next/navigation\";\nimport { useEffect, useMemo, useState } from \"react\";\nimport { z } from \"zod\";\n\nimport { parseSearchParams } from \"../helpers/parseSearchParams\";\nimport { setSearchParams } from \"../helpers/setSearchParams\";\n\nexport const useSearchParams = <T extends Record<string, z.ZodType>, >(config: (zod: typeof z) => T) => {\n    const schema = useMemo(() => z.object(config(z)), []);\n    const entry = useMemo(() => config(z), []);\n\n    const searchParams = useSearchParamsNext();\n\n    const [data, setData] = useState(\n        parseSearchParams<z.infer<typeof schema>>(entry, searchParams.toString())\n    );\n\n    useEffect(() => {\n        setData(parseSearchParams<z.infer<typeof schema>>(entry, searchParams.toString()));\n    }, [searchParams, schema, entry]);\n\n    useEffect(() => {\n        const handler = () => {\n            setData(parseSearchParams<z.infer<typeof schema>>(entry, window.location.search.substring(1)));\n        }\n        window.addEventListener('setSearchParams', handler);\n        return () => window.removeEventListener('setSearchParams', handler);\n    }, [entry]);\n\n    return [data as z.infer<typeof schema>, setSearchParams];\n}\n"],"names":["settings","this","arrayFormat","arrayFormatSeparator","stringifySearchParams","searchParams","queryString","stringify","Settings","encode","skipNull","skipEmptyString","setSearchParams","entry","href","concat","window","location","pathname","history","replaceState","__assign","state","as","new","dispatchEvent","Event","parseValue","value","schema","undefined","_a","safeParse","success","data","parseSearchParams","searchParamsString","parsedSearchParams","parse","decodeURIComponent","result","key","options","config","useMemo","z","object","useSearchParamsNext","useState","toString","setData","useEffect","handler","search","substring","addEventListener","removeEventListener"],"mappings":";;;;;obAEA,IAKMA,EAAW,IALjB,WACIC,KAAWC,YAAoB,UAC/BD,KAAoBE,qBAAW,GAClC,0QCDM,IAAMC,EAAwB,SAACC,GAClC,OAAOC,EAAYC,UAAUF,EAAc,CACvCH,YAAaM,EAASN,YACtBC,qBAAsB,IACtBM,QAAQ,EACRC,UAAU,EACVC,iBAAiB,GAEzB,ECVaC,EAAkB,SAACC,GAC5B,IAAMC,EAAO,GAAGC,OAAAC,OAAOC,SAASC,SAAQ,KAAMd,EAAsBS,GACpEM,QAAQC,aAAYC,EAAAA,EAAA,CAAA,EACbF,QAAQG,QACXC,GAAIT,EACJU,IAAKV,IACN,GAAIA,GAEPE,OAAOS,cAAc,IAAIC,MAAM,mBACnC,ECTaC,EAAa,SAACC,EAAYC,GACnC,QAAeC,IAAXD,EAAJ,CAGM,IAAAE,EAAoBF,EAAOG,UAAUJ,GAAnCK,EAAOF,EAAAE,QAAEC,SACjB,OAAID,EACOC,OADX,CAFC,CAOL,ECNaC,EAAoB,SAAMN,EAAmCO,GACtE,IAAMC,EAAqB/B,EAAYgC,MAAMC,mBAAmBH,GAAqB,CACjFlC,YAAaM,EAASN,cAEpBsC,EAA8B,CAAA,EAEpC,IAAK,IAAIC,KAAOZ,EACZW,EAAOC,GAAOd,EAAWU,EAAmBI,GAAMZ,EAAOY,SAAQX,GAGrE,OAAOU,CACX,cCdM,SAAoBE,GAIlBA,EAAqB,cACrBlC,EAASN,YAAcwC,EAAqB,aAG5CA,EAA8B,uBAC9BlC,EAASL,qBAAuBuC,EAA8B,qBAEtE,kECP+B,SAAwCC,GACnE,IAAMd,EAASe,EAAAA,SAAQ,WAAM,OAAAC,EAAAA,EAAEC,OAAOH,EAAOE,KAAG,GAAE,IAC5ChC,EAAQ+B,EAAOA,SAAC,WAAM,OAAAD,EAAOE,OAAI,IAEjCxC,EAAe0C,EAAAA,kBAEfhB,EAAkBiB,EAAAA,SACpBb,EAA0CtB,EAAOR,EAAa4C,aAD3Df,OAAMgB,OAgBb,OAZAC,EAAAA,WAAU,WACND,EAAQf,EAA0CtB,EAAOR,EAAa4C,YACzE,GAAE,CAAC5C,EAAcwB,EAAQhB,IAE1BsC,EAAAA,WAAU,WACN,IAAMC,EAAU,WACZF,EAAQf,EAA0CtB,EAAOG,OAAOC,SAASoC,OAAOC,UAAU,IAC9F,EAEA,OADAtC,OAAOuC,iBAAiB,kBAAmBH,GACpC,WAAM,OAAApC,OAAOwC,oBAAoB,kBAAmBJ,GAC/D,GAAG,CAACvC,IAEG,CAACqB,EAAgCtB,EAC5C"}